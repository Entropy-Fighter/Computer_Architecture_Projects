# 目录

[toc]





# How to Get Good Performance by Using OpenMP!

## 一、单个线程可以做到的优化

### 1. 数组的每一行是连续的地址空间——能够被装入缓存块，列不行

![image-20220512140120748](./.pic/image-20220512140120748.png)

### 2. loop unrolling

![image-20220512140224779](./.pic/image-20220512140224779.png)

- 这个可以配合INTEL SIMD使用

### 3. loop fusion 循环合并

- 循环访问同一个数组时，将所有操作都集中在这次循环中——利用缓存

![image-20220512140333341](./.pic/image-20220512140333341.png)

### 4. loop fission 循环拆分

将独立的计算从原有的循环中分离——利用缓存

![image-20220512140545092](./.pic/image-20220512140545092.png)

### 5. loop tiling将嵌套循环分为小部分来做

![image-20220512140841632](./.pic/image-20220512140841632.png)

- 这个例子演示了快速的矩阵转置方法

## 二、使用多线程优化

### 1.测量优化的效果

- 使用Linux的`time`指令
- 使用`omp_get_wtime()`函数

### 2. parallel overhead：为了协调多线程而花费的时间（负作用）

时间单位都是微秒，即$10^{-6}$秒，影响不太大

![image-20220512141911776](./.pic/image-20220512141911776.png)

![image-20220512141933630](./.pic/image-20220512141933630.png)

![image-20220512142227054](./.pic/image-20220512142227054.png)

![image-20220512142233919](./.pic/image-20220512142233919.png)

#### (a) 尽量不要使用同步机制

- 比如critical region

#### (b) maximize parallel region

![image-20220512142712939](./.pic/image-20220512142712939.png)

- 看右上角的小图，每一次fork（启动并行区域）都会花费时间，且每一次都需要保证所有线程运行完毕才能结束
- 应该这样：

![image-20220512142842330](./.pic/image-20220512142842330.png)

#### (c)内层循环不应该开启parallel region

![image-20220512142931156](./.pic/image-20220512142931156.png)

### 3. load balance：平衡每个线程的工作量

![image-20220512143248522](./.pic/image-20220512143248522.png)

- 避免忙的忙死，闲的闲死

例子：

![image-20220512143458871](./.pic/image-20220512143458871.png)

![image-20220512143507214](./.pic/image-20220512143507214.png)

### 4.false sharing：多个线程频繁修改缓存区

![image-20220512143756081](./.pic/image-20220512143756081.png)

![image-20220512143813239](./.pic/image-20220512143813239.png)

例子：

![image-20220512144009742](./.pic/image-20220512144009742.png)

![image-20220512144035071](./.pic/image-20220512144035071.png)

![image-20220512144216804](./.pic/image-20220512144216804.png)



